/*! VideocallSDK v1.0.0 | MIT License */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).VideocallSDK=t()}(this,function(){"use strict";class e{constructor(e){if(this.baseUrl=e.baseUrl||"http://localhost:8080/api/v1",this.apiKey=e.apiKey,!this.apiKey)throw new Error("API key is required")}async request(e,t={}){const o=`${this.baseUrl}${e}`,r={"Content-Type":"application/json","X-API-Key":this.apiKey,...t.headers},s={method:t.method||"GET",headers:r,...t};t.body&&"object"==typeof t.body&&(s.body=JSON.stringify(t.body));try{const e=await fetch(o,s);if(!e.ok){const t=await e.json().catch(()=>({}));throw new Error(t.message||`HTTP ${e.status}: ${e.statusText}`)}const t=e.headers.get("content-type");return t&&t.includes("application/json")?await e.json():await e.text()}catch(e){if("TypeError"===e.name&&e.message.includes("fetch"))throw new Error("Network error: Unable to connect to VideocallAPI");throw e}}async createRoom(e){return this.request("/rooms",{method:"POST",body:e})}async getRooms(){return this.request("/rooms")}async getRoom(e){return this.request(`/rooms/${e}`)}async startRoom(e){return this.request(`/rooms/${e}/start`,{method:"POST"})}async endRoom(e){return this.request(`/rooms/${e}/end`,{method:"POST"})}async getRoomJoinInfo(e){const t=`${this.baseUrl}/rooms/join/${e}`,o=await fetch(t);if(!o.ok)throw new Error(`Room not found: ${e}`);return o.json()}}function t(){const e=["quick","bright","calm","smart","fresh","cool","warm","safe"],t=["meeting","room","space","call","chat","talk","session","conference"];return`${e[Math.floor(Math.random()*e.length)]}-${t[Math.floor(Math.random()*t.length)]}-${Math.floor(1e3*Math.random())}`}function o(e){const t=[];return e.name&&0!==e.name.trim().length||t.push("Room name is required"),e.name&&e.name.length>100&&t.push("Room name must be less than 100 characters"),e.description&&e.description.length>500&&t.push("Description must be less than 500 characters"),e.maxParticipants&&(e.maxParticipants<2||e.maxParticipants>100)&&t.push("Max participants must be between 2 and 100"),e.isPasswordProtected&&!e.password&&t.push("Password is required when room is password protected"),t}function r(){const e={webrtc:!(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia),fetch:!!window.fetch,promises:!!window.Promise,websockets:!!window.WebSocket};return{supported:0===Object.entries(e).filter(([e,t])=>!t).length,missing:Object.entries(e).filter(([e,t])=>!t).map(([e])=>e)}}class s{constructor(e=!1){this.enabled=e}log(e,t=null){this.enabled&&console.log(`[VideocallSDK] ${e}`,t||"")}error(e,t=null){this.enabled&&console.error(`[VideocallSDK Error] ${e}`,t||"")}warn(e,t=null){this.enabled&&console.warn(`[VideocallSDK Warning] ${e}`,t||"")}}class n{constructor(){this.events={}}on(e,t){this.events[e]||(this.events[e]=[]),this.events[e].push(t)}off(e,t){this.events[e]&&(this.events[e]=this.events[e].filter(e=>e!==t))}emit(e,t=null){this.events[e]&&this.events[e].forEach(e=>{try{e(t)}catch(e){console.error(`Error in event callback for ${event}:`,e)}})}}return class extends n{constructor(n={}){if(super(),!n.apiKey)throw new Error("VideocallSDK: API key is required");this.config={baseUrl:"http://localhost:8080/api/v1",debug:!1,autoStart:!0,...n},this.apiClient=new e(this.config),this.logger=new s(this.config.debug),this.rooms=new Map,this.logger.log("VideocallSDK initialized",this.config);const i=r();if(!i.supported)throw this.logger.error("Browser missing required features:",i.missing),new Error(`Browser not supported. Missing: ${i.missing.join(", ")}`)}async createRoom(e={}){try{const r={name:t(),maxParticipants:10,isRecordingEnabled:!1,isPasswordProtected:!1,...e},s=o(r);if(s.length>0)throw new Error(`Invalid room configuration: ${s.join(", ")}`);this.logger.log("Creating room",r);const n=await this.apiClient.createRoom(r);return this.rooms.set(n.roomId,n),this.config.autoStart&&await this.startRoom(n.roomId),this.emit("roomCreated",n),this.logger.log("Room created successfully",n),n}catch(e){throw this.logger.error("Failed to create room",e),this.emit("error",{type:"createRoom",error:e}),e}}async joinRoom(e){try{this.logger.log("Getting room join info",e);const t=await this.apiClient.getRoomJoinInfo(e);return this.emit("roomJoined",t),t}catch(t){throw this.logger.error("Failed to join room",t),this.emit("error",{type:"joinRoom",error:t}),t}}async startRoom(e){try{this.logger.log("Starting room",e);const t=await this.apiClient.startRoom(e);if(this.rooms.has(e)){const t=this.rooms.get(e);t.startedAt=(new Date).toISOString(),this.rooms.set(e,t)}return this.emit("roomStarted",{roomId:e,result:t}),t}catch(t){throw this.logger.error("Failed to start room",t),this.emit("error",{type:"startRoom",error:t}),t}}async getRooms(){try{this.logger.log("Fetching rooms");const e=await this.apiClient.getRooms();return e.forEach(e=>{this.rooms.set(e.roomId,e)}),e}catch(e){throw this.logger.error("Failed to get rooms",e),this.emit("error",{type:"getRooms",error:e}),e}}openRoom(e,t="width=1200,height=800"){const o=this.rooms.get(e);if(!o)throw new Error(`Room ${e} not found in cache. Call getRoom() first.`);const r=window.open(o.jitsiUrl,"_blank",t);if(!r)throw new Error("Failed to open room. Pop-ups might be blocked.");return this.emit("roomOpened",{roomId:e,window:r}),r}getCachedRoom(e){return this.rooms.get(e)}static generateRoomName=t;static checkBrowserSupport=r}});
